<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DLAF: /home/runner/work/DLA-Future/DLA-Future/include/dlaf/lapack/tile.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DLAF
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_415b543d06dcd728a2539f6ad76147ea.html">dlaf</a></li><li class="navelem"><a class="el" href="dir_d7e5084879c595d98fc3a7946899b578.html">lapack</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">tile.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;cstddef&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;lapack.hh&gt;</code><br />
<code>#include &lt;dlaf/common/assert.h&gt;</code><br />
<code>#include &lt;<a class="el" href="callable__object_8h_source.html">dlaf/common/callable_object.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="single__threaded__blas_8h_source.html">dlaf/common/single_threaded_blas.h</a>&gt;</code><br />
<code>#include &lt;dlaf/lapack/enum_output.h&gt;</code><br />
<code>#include &lt;<a class="el" href="matrix_2index_8h_source.html">dlaf/matrix/index.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="matrix_2tile_8h_source.html">dlaf/matrix/tile.h</a>&gt;</code><br />
<code>#include &lt;dlaf/sender/make_sender_algorithm_overloads.h&gt;</code><br />
<code>#include &lt;dlaf/sender/policy.h&gt;</code><br />
<code>#include &lt;dlaf/sender/transform.h&gt;</code><br />
<code>#include &lt;<a class="el" href="types_8h_source.html">dlaf/types.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="util__lapack_8h_source.html">dlaf/util_lapack.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="util__tile_8h_source.html">dlaf/util_tile.h</a>&gt;</code><br />
<code>#include &lt;whip.hpp&gt;</code><br />
<code>#include &lt;pika/cuda.hpp&gt;</code><br />
<code>#include &lt;dlaf/gpu/lapack/api.h&gt;</code><br />
<code>#include &lt;dlaf/gpu/lapack/assert_info.h&gt;</code><br />
<code>#include &lt;dlaf/gpu/lapack/error.h&gt;</code><br />
<code>#include &lt;dlaf/lapack/gpu/laset.h&gt;</code><br />
<code>#include &lt;dlaf/util_cublas.h&gt;</code><br />
</div>
<p><a href="lapack_2tile_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:adba78fac5535c410d8bd2e6c53ff8c7d" id="r_adba78fac5535c410d8bd2e6c53ff8c7d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:adba78fac5535c410d8bd2e6c53ff8c7d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="lapack_2tile_8h.html#adba78fac5535c410d8bd2e6c53ff8c7d">dlaf::tile::lacpy</a> (const <a class="el" href="classdlaf_1_1matrix_1_1_tile.html">Tile</a>&lt; const T, Device::CPU &gt; &amp;a, const <a class="el" href="classdlaf_1_1matrix_1_1_tile.html">Tile</a>&lt; T, Device::CPU &gt; &amp;b)</td></tr>
<tr class="separator:adba78fac5535c410d8bd2e6c53ff8c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbf24144aebc55d9d50bb3b53ae38f7" id="r_a1bbf24144aebc55d9d50bb3b53ae38f7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1bbf24144aebc55d9d50bb3b53ae38f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="lapack_2tile_8h.html#a1bbf24144aebc55d9d50bb3b53ae38f7">dlaf::tile::lacpy</a> (<a class="el" href="classdlaf_1_1common_1_1_size2_d.html">TileElementSize</a> region, <a class="el" href="classdlaf_1_1common_1_1_index2_d.html">TileElementIndex</a> in_idx, const <a class="el" href="classdlaf_1_1matrix_1_1_tile.html">Tile</a>&lt; const T, Device::CPU &gt; &amp;in, <a class="el" href="classdlaf_1_1common_1_1_index2_d.html">TileElementIndex</a> out_idx, const <a class="el" href="classdlaf_1_1matrix_1_1_tile.html">Tile</a>&lt; T, Device::CPU &gt; &amp;out)</td></tr>
<tr class="separator:a1bbf24144aebc55d9d50bb3b53ae38f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3873df04fe8430177930b56d3cc7883" id="r_af3873df04fe8430177930b56d3cc7883"><td class="memTemplParams" colspan="2">template&lt;Backend B, class T , Device D&gt; </td></tr>
<tr class="memitem:af3873df04fe8430177930b56d3cc7883"><td class="memTemplItemLeft" align="right" valign="top">dlaf::BaseType&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="lapack_2tile_8h.html#af3873df04fe8430177930b56d3cc7883">dlaf::tile::lange</a> (const <a class="el" href="classdlaf_1_1internal_1_1_policy.html">dlaf::internal::Policy</a>&lt; B &gt; &amp;p, const lapack::Norm norm, const <a class="el" href="classdlaf_1_1matrix_1_1_tile.html">Tile</a>&lt; T, D &gt; &amp;a)</td></tr>
<tr class="separator:af3873df04fe8430177930b56d3cc7883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d84a029a43790f54cea96505a6ff19" id="r_a48d84a029a43790f54cea96505a6ff19"><td class="memTemplParams" colspan="2"><a id="a48d84a029a43790f54cea96505a6ff19" name="a48d84a029a43790f54cea96505a6ff19"></a>
template&lt;Backend B, typename Sender , typename  = std::enable_if_t&lt;pika::execution::experimental::is_sender_v&lt;Sender&gt;&gt;&gt; </td></tr>
<tr class="memitem:a48d84a029a43790f54cea96505a6ff19"><td class="memTemplItemLeft" align="right" valign="top">dlaf::BaseType&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dlaf::tile::lange</b> (const <a class="el" href="classdlaf_1_1internal_1_1_policy.html">dlaf::internal::Policy</a>&lt; B &gt; &amp;p, Sender &amp;&amp;s)</td></tr>
<tr class="separator:a48d84a029a43790f54cea96505a6ff19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb64e6202af19ea05f87e90e1cc3456d" id="r_afb64e6202af19ea05f87e90e1cc3456d"><td class="memTemplParams" colspan="2"><a id="afb64e6202af19ea05f87e90e1cc3456d" name="afb64e6202af19ea05f87e90e1cc3456d"></a>
template&lt;Backend B&gt; </td></tr>
<tr class="memitem:afb64e6202af19ea05f87e90e1cc3456d"><td class="memTemplItemLeft" align="right" valign="top">dlaf::BaseType&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dlaf::tile::lange</b> (const <a class="el" href="classdlaf_1_1internal_1_1_policy.html">dlaf::internal::Policy</a>&lt; B &gt; &amp;p)</td></tr>
<tr class="separator:afb64e6202af19ea05f87e90e1cc3456d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760575503b01d456b9871ee228c6bfe6" id="r_a760575503b01d456b9871ee228c6bfe6"><td class="memTemplParams" colspan="2">template&lt;Backend B, class T , Device D&gt; </td></tr>
<tr class="memitem:a760575503b01d456b9871ee228c6bfe6"><td class="memTemplItemLeft" align="right" valign="top">dlaf::BaseType&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="lapack_2tile_8h.html#a760575503b01d456b9871ee228c6bfe6">dlaf::tile::lantr</a> (const <a class="el" href="classdlaf_1_1internal_1_1_policy.html">dlaf::internal::Policy</a>&lt; B &gt; &amp;p, const lapack::Norm norm, const blas::Uplo uplo, const blas::Diag diag, const <a class="el" href="classdlaf_1_1matrix_1_1_tile.html">Tile</a>&lt; T, D &gt; &amp;a)</td></tr>
<tr class="separator:a760575503b01d456b9871ee228c6bfe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f770f9a604236fff2b6b6844ec98dee" id="r_a0f770f9a604236fff2b6b6844ec98dee"><td class="memTemplParams" colspan="2"><a id="a0f770f9a604236fff2b6b6844ec98dee" name="a0f770f9a604236fff2b6b6844ec98dee"></a>
template&lt;Backend B, typename Sender , typename  = std::enable_if_t&lt;pika::execution::experimental::is_sender_v&lt;Sender&gt;&gt;&gt; </td></tr>
<tr class="memitem:a0f770f9a604236fff2b6b6844ec98dee"><td class="memTemplItemLeft" align="right" valign="top">dlaf::BaseType&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dlaf::tile::lantr</b> (const <a class="el" href="classdlaf_1_1internal_1_1_policy.html">dlaf::internal::Policy</a>&lt; B &gt; &amp;p, Sender &amp;&amp;s)</td></tr>
<tr class="separator:a0f770f9a604236fff2b6b6844ec98dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10869aab90ba767365dd1da7ce7aeb2d" id="r_a10869aab90ba767365dd1da7ce7aeb2d"><td class="memTemplParams" colspan="2"><a id="a10869aab90ba767365dd1da7ce7aeb2d" name="a10869aab90ba767365dd1da7ce7aeb2d"></a>
template&lt;Backend B&gt; </td></tr>
<tr class="memitem:a10869aab90ba767365dd1da7ce7aeb2d"><td class="memTemplItemLeft" align="right" valign="top">dlaf::BaseType&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dlaf::tile::lantr</b> (const <a class="el" href="classdlaf_1_1internal_1_1_policy.html">dlaf::internal::Policy</a>&lt; B &gt; &amp;p)</td></tr>
<tr class="separator:a10869aab90ba767365dd1da7ce7aeb2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19439efac55cc846b684ed2c6f78eb33" id="r_a19439efac55cc846b684ed2c6f78eb33"><td class="memTemplParams" colspan="2">template&lt;Backend B, class T , Device D&gt; </td></tr>
<tr class="memitem:a19439efac55cc846b684ed2c6f78eb33"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="lapack_2tile_8h.html#a19439efac55cc846b684ed2c6f78eb33">dlaf::tile::laset</a> (const <a class="el" href="classdlaf_1_1internal_1_1_policy.html">dlaf::internal::Policy</a>&lt; B &gt; &amp;p, const blas::Uplo uplo, T alpha, T beta, const <a class="el" href="classdlaf_1_1matrix_1_1_tile.html">Tile</a>&lt; T, D &gt; &amp;tile)</td></tr>
<tr class="separator:a19439efac55cc846b684ed2c6f78eb33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d5fbcaa4f1ac96f17010384df34d08" id="r_a00d5fbcaa4f1ac96f17010384df34d08"><td class="memTemplParams" colspan="2"><a id="a00d5fbcaa4f1ac96f17010384df34d08" name="a00d5fbcaa4f1ac96f17010384df34d08"></a>
template&lt;Backend B, typename Sender , typename  = std::enable_if_t&lt;pika::execution::experimental::is_sender_v&lt;Sender&gt;&gt;&gt; </td></tr>
<tr class="memitem:a00d5fbcaa4f1ac96f17010384df34d08"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dlaf::tile::laset</b> (const <a class="el" href="classdlaf_1_1internal_1_1_policy.html">dlaf::internal::Policy</a>&lt; B &gt; &amp;p, Sender &amp;&amp;s)</td></tr>
<tr class="separator:a00d5fbcaa4f1ac96f17010384df34d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f4e77f59a7c39db5a05e1c0ffb867a5" id="r_a6f4e77f59a7c39db5a05e1c0ffb867a5"><td class="memTemplParams" colspan="2"><a id="a6f4e77f59a7c39db5a05e1c0ffb867a5" name="a6f4e77f59a7c39db5a05e1c0ffb867a5"></a>
template&lt;Backend B&gt; </td></tr>
<tr class="memitem:a6f4e77f59a7c39db5a05e1c0ffb867a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dlaf::tile::laset</b> (const <a class="el" href="classdlaf_1_1internal_1_1_policy.html">dlaf::internal::Policy</a>&lt; B &gt; &amp;p)</td></tr>
<tr class="separator:a6f4e77f59a7c39db5a05e1c0ffb867a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab094eeac6052422b50a298b42a947251" id="r_ab094eeac6052422b50a298b42a947251"><td class="memTemplParams" colspan="2">template&lt;Backend B, class T , Device D&gt; </td></tr>
<tr class="memitem:ab094eeac6052422b50a298b42a947251"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="lapack_2tile_8h.html#ab094eeac6052422b50a298b42a947251">dlaf::tile::set0</a> (const <a class="el" href="classdlaf_1_1internal_1_1_policy.html">dlaf::internal::Policy</a>&lt; B &gt; &amp;p, const <a class="el" href="classdlaf_1_1matrix_1_1_tile.html">Tile</a>&lt; T, D &gt; &amp;tile)</td></tr>
<tr class="separator:ab094eeac6052422b50a298b42a947251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e050980179c5eec971ace79d95d8ca4" id="r_a3e050980179c5eec971ace79d95d8ca4"><td class="memTemplParams" colspan="2"><a id="a3e050980179c5eec971ace79d95d8ca4" name="a3e050980179c5eec971ace79d95d8ca4"></a>
template&lt;Backend B, typename Sender , typename  = std::enable_if_t&lt;pika::execution::experimental::is_sender_v&lt;Sender&gt;&gt;&gt; </td></tr>
<tr class="memitem:a3e050980179c5eec971ace79d95d8ca4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dlaf::tile::set0</b> (const <a class="el" href="classdlaf_1_1internal_1_1_policy.html">dlaf::internal::Policy</a>&lt; B &gt; &amp;p, Sender &amp;&amp;s)</td></tr>
<tr class="separator:a3e050980179c5eec971ace79d95d8ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243981e245003c6dc645717fe92d2dc3" id="r_a243981e245003c6dc645717fe92d2dc3"><td class="memTemplParams" colspan="2"><a id="a243981e245003c6dc645717fe92d2dc3" name="a243981e245003c6dc645717fe92d2dc3"></a>
template&lt;Backend B&gt; </td></tr>
<tr class="memitem:a243981e245003c6dc645717fe92d2dc3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dlaf::tile::set0</b> (const <a class="el" href="classdlaf_1_1internal_1_1_policy.html">dlaf::internal::Policy</a>&lt; B &gt; &amp;p)</td></tr>
<tr class="separator:a243981e245003c6dc645717fe92d2dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf274e91e36453e7994dd1f2a2813681" id="r_aaf274e91e36453e7994dd1f2a2813681"><td class="memTemplParams" colspan="2">template&lt;Backend B, class T , Device D&gt; </td></tr>
<tr class="memitem:aaf274e91e36453e7994dd1f2a2813681"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="lapack_2tile_8h.html#aaf274e91e36453e7994dd1f2a2813681">dlaf::tile::hegst</a> (const <a class="el" href="classdlaf_1_1internal_1_1_policy.html">dlaf::internal::Policy</a>&lt; B &gt; &amp;, const int itype, const blas::Uplo uplo, const <a class="el" href="classdlaf_1_1matrix_1_1_tile.html">Tile</a>&lt; T, D &gt; &amp;a, const <a class="el" href="classdlaf_1_1matrix_1_1_tile.html">Tile</a>&lt; T, D &gt; &amp;b)</td></tr>
<tr class="separator:aaf274e91e36453e7994dd1f2a2813681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb59d8bad3c64ea8bb84b53b2ecbc0e5" id="r_adb59d8bad3c64ea8bb84b53b2ecbc0e5"><td class="memTemplParams" colspan="2"><a id="adb59d8bad3c64ea8bb84b53b2ecbc0e5" name="adb59d8bad3c64ea8bb84b53b2ecbc0e5"></a>
template&lt;Backend B, typename Sender , typename  = std::enable_if_t&lt;pika::execution::experimental::is_sender_v&lt;Sender&gt;&gt;&gt; </td></tr>
<tr class="memitem:adb59d8bad3c64ea8bb84b53b2ecbc0e5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dlaf::tile::hegst</b> (const <a class="el" href="classdlaf_1_1internal_1_1_policy.html">dlaf::internal::Policy</a>&lt; B &gt; &amp;p, Sender &amp;&amp;s)</td></tr>
<tr class="separator:adb59d8bad3c64ea8bb84b53b2ecbc0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346b5f3178be63106064b1c17331dfda" id="r_a346b5f3178be63106064b1c17331dfda"><td class="memTemplParams" colspan="2"><a id="a346b5f3178be63106064b1c17331dfda" name="a346b5f3178be63106064b1c17331dfda"></a>
template&lt;Backend B&gt; </td></tr>
<tr class="memitem:a346b5f3178be63106064b1c17331dfda"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dlaf::tile::hegst</b> (const <a class="el" href="classdlaf_1_1internal_1_1_policy.html">dlaf::internal::Policy</a>&lt; B &gt; &amp;p)</td></tr>
<tr class="separator:a346b5f3178be63106064b1c17331dfda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa917a1efbd53213821776d7d632ee41c" id="r_aa917a1efbd53213821776d7d632ee41c"><td class="memTemplParams" colspan="2">template&lt;Backend B, class T , Device D&gt; </td></tr>
<tr class="memitem:aa917a1efbd53213821776d7d632ee41c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="lapack_2tile_8h.html#aa917a1efbd53213821776d7d632ee41c">dlaf::tile::potrfInfo</a> (const <a class="el" href="classdlaf_1_1internal_1_1_policy.html">dlaf::internal::Policy</a>&lt; B &gt; &amp;, const blas::Uplo uplo, const <a class="el" href="classdlaf_1_1matrix_1_1_tile.html">Tile</a>&lt; T, D &gt; &amp;a)</td></tr>
<tr class="separator:aa917a1efbd53213821776d7d632ee41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8027b3a9325ee46d84c36df3e41863f" id="r_ab8027b3a9325ee46d84c36df3e41863f"><td class="memTemplParams" colspan="2"><a id="ab8027b3a9325ee46d84c36df3e41863f" name="ab8027b3a9325ee46d84c36df3e41863f"></a>
template&lt;Backend B, typename Sender , typename  = std::enable_if_t&lt;pika::execution::experimental::is_sender_v&lt;Sender&gt;&gt;&gt; </td></tr>
<tr class="memitem:ab8027b3a9325ee46d84c36df3e41863f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dlaf::tile::potrfInfo</b> (const <a class="el" href="classdlaf_1_1internal_1_1_policy.html">dlaf::internal::Policy</a>&lt; B &gt; &amp;p, Sender &amp;&amp;s)</td></tr>
<tr class="separator:ab8027b3a9325ee46d84c36df3e41863f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ab48f8316961a1ba034a0c79874805" id="r_af0ab48f8316961a1ba034a0c79874805"><td class="memTemplParams" colspan="2"><a id="af0ab48f8316961a1ba034a0c79874805" name="af0ab48f8316961a1ba034a0c79874805"></a>
template&lt;Backend B&gt; </td></tr>
<tr class="memitem:af0ab48f8316961a1ba034a0c79874805"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dlaf::tile::potrfInfo</b> (const <a class="el" href="classdlaf_1_1internal_1_1_policy.html">dlaf::internal::Policy</a>&lt; B &gt; &amp;p)</td></tr>
<tr class="separator:af0ab48f8316961a1ba034a0c79874805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0795227301a9e8e63232028e331fe0" id="r_aab0795227301a9e8e63232028e331fe0"><td class="memTemplParams" colspan="2">template&lt;Backend B, class T , Device D&gt; </td></tr>
<tr class="memitem:aab0795227301a9e8e63232028e331fe0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="lapack_2tile_8h.html#aab0795227301a9e8e63232028e331fe0">dlaf::tile::potrf</a> (const <a class="el" href="classdlaf_1_1internal_1_1_policy.html">dlaf::internal::Policy</a>&lt; B &gt; &amp;p, const blas::Uplo uplo, const <a class="el" href="classdlaf_1_1matrix_1_1_tile.html">Tile</a>&lt; T, D &gt; &amp;a)</td></tr>
<tr class="separator:aab0795227301a9e8e63232028e331fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d91163f2dde07d5c526c9cd6e28e20" id="r_a27d91163f2dde07d5c526c9cd6e28e20"><td class="memTemplParams" colspan="2"><a id="a27d91163f2dde07d5c526c9cd6e28e20" name="a27d91163f2dde07d5c526c9cd6e28e20"></a>
template&lt;Backend B, typename Sender , typename  = std::enable_if_t&lt;pika::execution::experimental::is_sender_v&lt;Sender&gt;&gt;&gt; </td></tr>
<tr class="memitem:a27d91163f2dde07d5c526c9cd6e28e20"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dlaf::tile::potrf</b> (const <a class="el" href="classdlaf_1_1internal_1_1_policy.html">dlaf::internal::Policy</a>&lt; B &gt; &amp;p, Sender &amp;&amp;s)</td></tr>
<tr class="separator:a27d91163f2dde07d5c526c9cd6e28e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39867885a93499be623f55888dffb41" id="r_ae39867885a93499be623f55888dffb41"><td class="memTemplParams" colspan="2"><a id="ae39867885a93499be623f55888dffb41" name="ae39867885a93499be623f55888dffb41"></a>
template&lt;Backend B&gt; </td></tr>
<tr class="memitem:ae39867885a93499be623f55888dffb41"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dlaf::tile::potrf</b> (const <a class="el" href="classdlaf_1_1internal_1_1_policy.html">dlaf::internal::Policy</a>&lt; B &gt; &amp;p)</td></tr>
<tr class="separator:ae39867885a93499be623f55888dffb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68163899b7b15f447fdbb05e475d9cc6" id="r_a68163899b7b15f447fdbb05e475d9cc6"><td class="memTemplParams" colspan="2">template&lt;Backend B, class T , Device D&gt; </td></tr>
<tr class="memitem:a68163899b7b15f447fdbb05e475d9cc6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="lapack_2tile_8h.html#a68163899b7b15f447fdbb05e475d9cc6">dlaf::tile::stedc</a> (const <a class="el" href="classdlaf_1_1internal_1_1_policy.html">dlaf::internal::Policy</a>&lt; B &gt; &amp;p, const <a class="el" href="classdlaf_1_1matrix_1_1_tile.html">Tile</a>&lt; T, D &gt; &amp;tridiag, const <a class="el" href="classdlaf_1_1matrix_1_1_tile.html">Tile</a>&lt; T, D &gt; &amp;evecs)</td></tr>
<tr class="separator:a68163899b7b15f447fdbb05e475d9cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf951c9291222d810cae5f195d2167e5" id="r_acf951c9291222d810cae5f195d2167e5"><td class="memTemplParams" colspan="2"><a id="acf951c9291222d810cae5f195d2167e5" name="acf951c9291222d810cae5f195d2167e5"></a>
template&lt;Backend B, typename Sender , typename  = std::enable_if_t&lt;hpx::execution::experimental::is_sender_v&lt;Sender&gt;&gt;&gt; </td></tr>
<tr class="memitem:acf951c9291222d810cae5f195d2167e5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dlaf::tile::stedc</b> (const <a class="el" href="classdlaf_1_1internal_1_1_policy.html">dlaf::internal::Policy</a>&lt; B &gt; &amp;p, Sender &amp;&amp;s)</td></tr>
<tr class="separator:acf951c9291222d810cae5f195d2167e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f402da8b5dd5dd66218bf80cff0a69d" id="r_a8f402da8b5dd5dd66218bf80cff0a69d"><td class="memTemplParams" colspan="2"><a id="a8f402da8b5dd5dd66218bf80cff0a69d" name="a8f402da8b5dd5dd66218bf80cff0a69d"></a>
template&lt;Backend B&gt; </td></tr>
<tr class="memitem:a8f402da8b5dd5dd66218bf80cff0a69d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dlaf::tile::stedc</b> (const <a class="el" href="classdlaf_1_1internal_1_1_policy.html">dlaf::internal::Policy</a>&lt; B &gt; &amp;p)</td></tr>
<tr class="separator:a8f402da8b5dd5dd66218bf80cff0a69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="aaf274e91e36453e7994dd1f2a2813681" name="aaf274e91e36453e7994dd1f2a2813681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf274e91e36453e7994dd1f2a2813681">&#9670;&#160;</a></span>hegst()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Backend B, class T , Device D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dlaf::tile::hegst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdlaf_1_1internal_1_1_policy.html">dlaf::internal::Policy</a>&lt; B &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>itype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const blas::Uplo&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdlaf_1_1matrix_1_1_tile.html">Tile</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdlaf_1_1matrix_1_1_tile.html">Tile</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reduce a Hermitian definite generalized eigenproblem to standard form.</p>
<p>If <code>itype</code> = 1, the problem is A*x = lambda*B*x, and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H).</p>
<p>If <code>itype</code> = 2 or 3, the problem is A*B*x = lambda*x or B*A*x = lambda*x, and A is overwritten by U*A*(U**H) or (L**H)*A*L. B must have been previously factorized as (U**H)*U or L*(L**H) by potrf().</p>
<dl class="section pre"><dt>Precondition</dt><dd>a must be a complex Hermitian matrix or a symmetric real matrix (A), </dd>
<dd>
b must be the triangular factor from the Cholesky factorization of B, </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the tile was not positive definite.</td></tr>
  </table>
  </dd>
</dl>
<p>This overload blocks until completion of the algorithm. </p>

</div>
</div>
<a id="adba78fac5535c410d8bd2e6c53ff8c7d" name="adba78fac5535c410d8bd2e6c53ff8c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adba78fac5535c410d8bd2e6c53ff8c7d">&#9670;&#160;</a></span>lacpy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dlaf::tile::lacpy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdlaf_1_1matrix_1_1_tile.html">Tile</a>&lt; const T, Device::CPU &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdlaf_1_1matrix_1_1_tile.html">Tile</a>&lt; T, Device::CPU &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies all elements from Tile a to Tile b.</p>
<dl class="section pre"><dt>Precondition</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>and</td></tr>
    <tr><td class="paramname">b</td><td>must have the same size (number of elements).</td></tr>
  </table>
  </dd>
</dl>
<p>This overload blocks until completion of the algorithm. </p>

</div>
</div>
<a id="a1bbf24144aebc55d9d50bb3b53ae38f7" name="a1bbf24144aebc55d9d50bb3b53ae38f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bbf24144aebc55d9d50bb3b53ae38f7">&#9670;&#160;</a></span>lacpy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dlaf::tile::lacpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdlaf_1_1common_1_1_size2_d.html">TileElementSize</a>&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdlaf_1_1common_1_1_index2_d.html">TileElementIndex</a>&#160;</td>
          <td class="paramname"><em>in_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdlaf_1_1matrix_1_1_tile.html">Tile</a>&lt; const T, Device::CPU &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdlaf_1_1common_1_1_index2_d.html">TileElementIndex</a>&#160;</td>
          <td class="paramname"><em>out_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdlaf_1_1matrix_1_1_tile.html">Tile</a>&lt; T, Device::CPU &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies a 2D</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">region</td><td>from tile</td></tr>
    <tr><td class="paramname">in</td><td>starting at</td></tr>
    <tr><td class="paramname">in_idx</td><td>to tile</td></tr>
    <tr><td class="paramname">out</td><td>starting at</td></tr>
    <tr><td class="paramname">out_idx.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">region</td><td>has to fit within</td></tr>
    <tr><td class="paramname">in</td><td>and</td></tr>
    <tr><td class="paramname">out</td><td>taking into account the starting indices</td></tr>
    <tr><td class="paramname">in_idx</td><td>and</td></tr>
    <tr><td class="paramname">out_idx.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3873df04fe8430177930b56d3cc7883" name="af3873df04fe8430177930b56d3cc7883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3873df04fe8430177930b56d3cc7883">&#9670;&#160;</a></span>lange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Backend B, class T , Device D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">dlaf::BaseType&lt; T &gt; dlaf::tile::lange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdlaf_1_1internal_1_1_policy.html">dlaf::internal::Policy</a>&lt; B &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lapack::Norm&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdlaf_1_1matrix_1_1_tile.html">Tile</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the value of the 1-norm, Frobenius norm, infinity-norm, or the largest absolute value of any element, of a general rectangular matrix.</p>
<dl class="section pre"><dt>Precondition</dt><dd>a.size().isValid().</dd></dl>
<p>This overload blocks until completion of the algorithm. </p>

</div>
</div>
<a id="a760575503b01d456b9871ee228c6bfe6" name="a760575503b01d456b9871ee228c6bfe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a760575503b01d456b9871ee228c6bfe6">&#9670;&#160;</a></span>lantr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Backend B, class T , Device D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">dlaf::BaseType&lt; T &gt; dlaf::tile::lantr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdlaf_1_1internal_1_1_policy.html">dlaf::internal::Policy</a>&lt; B &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lapack::Norm&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const blas::Uplo&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const blas::Diag&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdlaf_1_1matrix_1_1_tile.html">Tile</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the value of the 1-norm, Frobenius norm, infinity-norm, or the largest absolute value of any element, of a triangular matrix.</p>
<dl class="section pre"><dt>Precondition</dt><dd>uplo != blas::Uplo::General, </dd>
<dd>
a.size().isValid(), </dd>
<dd>
a.size().rows() &gt;= a.size().cols() if uplo == blas::Uplo::Lower, </dd>
<dd>
a.size().rows() &lt;= a.size().cols() if uplo == blas::Uplo::Upper.</dd></dl>
<p>This overload blocks until completion of the algorithm. </p>

</div>
</div>
<a id="a19439efac55cc846b684ed2c6f78eb33" name="a19439efac55cc846b684ed2c6f78eb33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19439efac55cc846b684ed2c6f78eb33">&#9670;&#160;</a></span>laset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Backend B, class T , Device D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dlaf::tile::laset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdlaf_1_1internal_1_1_policy.html">dlaf::internal::Policy</a>&lt; B &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const blas::Uplo&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdlaf_1_1matrix_1_1_tile.html">Tile</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>tile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set off-diagonal (</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha)</td><td>and diagonal (</td></tr>
    <tr><td class="paramname">beta)</td><td>elements of Tile</td></tr>
    <tr><td class="paramname">tile.</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>This overload blocks until completion of the algorithm. </p>

</div>
</div>
<a id="aab0795227301a9e8e63232028e331fe0" name="aab0795227301a9e8e63232028e331fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab0795227301a9e8e63232028e331fe0">&#9670;&#160;</a></span>potrf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Backend B, class T , Device D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dlaf::tile::potrf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdlaf_1_1internal_1_1_policy.html">dlaf::internal::Policy</a>&lt; B &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const blas::Uplo&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdlaf_1_1matrix_1_1_tile.html">Tile</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the cholesky decomposition of a.</p>
<p>Only the upper or lower triangular elements are referenced according to <code>uplo</code>. </p><dl class="section pre"><dt>Precondition</dt><dd>matrix <code>a</code> is square, </dd>
<dd>
matrix <code>a</code> is positive definite.</dd></dl>
<p>This overload blocks until completion of the algorithm. </p>

</div>
</div>
<a id="aa917a1efbd53213821776d7d632ee41c" name="aa917a1efbd53213821776d7d632ee41c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa917a1efbd53213821776d7d632ee41c">&#9670;&#160;</a></span>potrfInfo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Backend B, class T , Device D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto dlaf::tile::potrfInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdlaf_1_1internal_1_1_policy.html">dlaf::internal::Policy</a>&lt; B &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const blas::Uplo&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdlaf_1_1matrix_1_1_tile.html">Tile</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the cholesky decomposition of a (with return code).</p>
<p>Only the upper or lower triangular elements are referenced according to <code>uplo</code>. </p><dl class="section return"><dt>Returns</dt><dd>info = 0 on success or info &gt; 0 if the tile is not positive definite.</dd></dl>
<p>This overload blocks until completion of the algorithm. </p>

</div>
</div>
<a id="ab094eeac6052422b50a298b42a947251" name="ab094eeac6052422b50a298b42a947251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab094eeac6052422b50a298b42a947251">&#9670;&#160;</a></span>set0()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Backend B, class T , Device D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dlaf::tile::set0 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdlaf_1_1internal_1_1_policy.html">dlaf::internal::Policy</a>&lt; B &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdlaf_1_1matrix_1_1_tile.html">Tile</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>tile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set zero all the elements of Tile</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tile.</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>This overload blocks until completion of the algorithm. </p>

</div>
</div>
<a id="a68163899b7b15f447fdbb05e475d9cc6" name="a68163899b7b15f447fdbb05e475d9cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68163899b7b15f447fdbb05e475d9cc6">&#9670;&#160;</a></span>stedc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Backend B, class T , Device D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dlaf::tile::stedc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdlaf_1_1internal_1_1_policy.html">dlaf::internal::Policy</a>&lt; B &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdlaf_1_1matrix_1_1_tile.html">Tile</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>tridiag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdlaf_1_1matrix_1_1_tile.html">Tile</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>evecs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the eigenvalues and eigenvectors of a real tridiagonal symmetric matrix using the divide &amp; conquer algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tridiag</td><td>is <code>n x 2</code>. On entry stores the tridiagonal symmetric matrix: the diagonal in the first column, the off-diagonal in the second column. The last entry of the second column is unused. On exit stores the eigenvalues in the 1st column in ascending order.</td></tr>
    <tr><td class="paramname">evecs</td><td>is <code>n x n</code>. On exit stores the eigenvectors of the tridiagonal symmetrix matrix. The order of the eigenvectors follows that of the eigenvalues.</td></tr>
  </table>
  </dd>
</dl>
<p>This overload blocks until completion of the algorithm. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
